<?xml version="1.0" ?>
  <rss
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:atom="http://www.w3.org/2005/Atom"
    version="2.0"
  >
    <channel>
        <title><![CDATA[IT-BLOG]]></title>
        <link>https://it-integ.ru</link>
        <description>
          <![CDATA[Блог об информационных технологиях]]>
        </description>
        <language>en</language>
        <lastBuildDate>2022-08-22</lastBuildDate>
        <item>
    <title><![CDATA[Установка кластера Kubernetes на Ubuntu 20.04]]></title>
    <link>https://it-integ.ru/kubernetes</link>
    <pubDate>2022-08-22</pubDate>
    <guid isPermaLink="false">https://it-integ.ru/kubernetes</guid>
    <description>
    <![CDATA[Как установить и настроить кластер Kubernetes на Ubuntu 20.04]]>
    </description>
    <content:encoded>
      <![CDATA[<p>Есть различные готовые реализации кластера Kubernetes, например:</p>
<ul>
<li><strong>Minikube</strong> — готовый кластер, который разворачивается на один компьютер - хороший способ познакомиться с Kubernetes.</li>
<li><strong>Kubespray</strong> — набор <em>Ansible</em> ролей.</li>
<li>Готовые кластеры в облаке, например <em>AWS, Google Cloud, Yandex Cloud</em> и так далее.
Использовать одну из готовых реализаций — быстрый и надежный способ развертывания системы оркестрации контейнеров <em>Docker</em>. Однако, мы рассмотрим ручное создание кластера Kubernetes из 3-х нод — один мастер (управление) и две рабочие ноды (запуск контейнеров).</li>
</ul>
<h2 id="подготовка-системы" class="heading">Подготовка системы</h2>
<p>Данные действия выполняем на всех узлах будущего кластера. Это необходимо, чтобы удовлетворить программные системные требования для нашего кластера.</p>
<ol>
<li>Задаем имена узлам, выполняив команды на соответствующих серверах:</li>
</ol>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">hostnamectl set-hostname k8s-master1.server.local
</span><span class="code-line">hostnamectl set-hostname k8s-worker1.server.local
</span><span class="code-line">hostnamectl set-hostname k8s-worker2.server.local
</span></code></pre>
<p>В данном примере мы зададим имя <em>k8s-master1</em> для мастера и <em>k8s-worker1</em>, <em>k8s-worker2</em> — для первого и второго рабочих нод, соотвественно. Чтобы наши серверы были доступны по заданным именам, на сервере DNS добавим соответствующие А-записи, либо правим файл hosts на каждом сервере:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">vi</span> /etc/hosts
</span></code></pre>
<p>добавляем записи(Вы можете использовать свои имена):</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token number">192.168</span>.0.15     k8s-master1.server.local k8s-master1
</span><span class="code-line"><span class="token number">192.168</span>.0.20     k8s-worker1.server.local k8s-worker1
</span><span class="code-line"><span class="token number">192.168</span>.0.25     k8s-worker2.server.local k8s-worker2
</span></code></pre>
<p>где, <em>192.168.0.15</em>, <em>192.168.0.20</em>, <em>192.168.0.25</em> — IP-адреса наших серверов, <em>k8s-master1</em>, <em>k8s-worker1</em>, <em>k8s-worker2</em> — имена серверов, server.local — наш внутренний домен.</p>
<ol start="2">
<li>Устанавливаем необходимые компоненты — дополнительные пакеты и утилиты. Для начала, обновим список пакетов и саму систему:</li>
</ol>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">apt-get</span> update <span class="token operator">&#x26;&#x26;</span> <span class="token function">apt-get</span> upgrade
</span></code></pre>
<p>Выполняем установку пакетов:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">curl</span> apt-transport-https <span class="token function">git</span> iptables-persistent
</span></code></pre>
<p>где:</p>
<ul>
<li><strong>git</strong> — утилита для работы с GIT. Понадобиться для загрузки файлов из репозитория git.</li>
<li><strong>curl</strong> — утилита для отправки GET, POST и других запросов на http-сервер. Понадобиться для загрузки ключа репозитория Kubernetes.</li>
<li><strong>apt-transport-https</strong> — позволяет получить доступ к APT-репозиториям по протоколу https.</li>
<li><strong>iptables-persistent</strong> — утилита для сохранения правил, созданных в iptables (не обязательна, но повышает удобство).
В процессе установки <em>iptables-persistent</em> может запросить подтверждение сохранить правила брандмауэра — отказываемся.</li>
</ul>
<ol start="3">
<li>Отключаем файл подкачки, так как с ним Kubernetes не запустится.
Выполняем команду для разового отключения:</li>
</ol>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> swapoff -a
</span></code></pre>
<p>Чтобы swap не появился после перезагрузки сервера, открываем на редактирование файл:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">vi</span> /etc/fstab
</span></code></pre>
<p>И комментируем строку:</p>
<p>#/swap.img      none    swap    sw      0       0</p>
<ol start="4">
<li>Загружаем дополнительные модули ядра.</li>
</ol>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">vi</span> /etc/modules-load.d/k8s.conf
</span><span class="code-line">
</span><span class="code-line">br_netfilter
</span><span class="code-line">overlay
</span></code></pre>
<ul>
<li>модуль <em>br_netfilter</em> расширяет возможности <em>netfilter</em>;</li>
<li><em>overlay</em> необходим для Docker. Загрузим модули в ядро:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> modprobe br_netfilter
</span><span class="code-line"><span class="token variable">$sudo</span> modprobe overlay
</span></code></pre>
<p>Проверяем, что данные модули работают:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> lsmod <span class="token operator">|</span> <span class="token function">egrep</span> <span class="token string">"br_netfilter|overlay"</span>
</span></code></pre>
<p>Мы должны увидеть что-то на подобие:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">overlay               <span class="token number">114688</span>  <span class="token number">10</span>
</span><span class="code-line">br_netfilter           <span class="token number">28672</span>  <span class="token number">0</span>
</span><span class="code-line">bridge                <span class="token number">176128</span>  <span class="token number">1</span> br_netfilter
</span></code></pre>
<ol start="5">
<li>Изменим параметры ядра. Создаем конфигурационный файл:</li>
</ol>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">vi</span> /etc/sysctl.d/k8s.conf 
</span><span class="code-line">
</span><span class="code-line">net.bridge.bridge-nf-call-ip6tables <span class="token operator">=</span> <span class="token number">1</span>
</span><span class="code-line">net.bridge.bridge-nf-call-iptables <span class="token operator">=</span> <span class="token number">1</span>
</span></code></pre>
<p><em>net.bridge.bridge-nf-call-iptables</em> контролирует возможность обработки трафика через bridge в netfilter. В нашем примере мы разрешаем данную обработку для IPv4 и IPv6.
Применяем параметры командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">sysctl --system
</span></code></pre>
<h2 id="брандмауэр" class="heading">Брандмауэр</h2>
<p>Для мастер-ноды и рабочей создаем разные наборы правил.
По умолчанию, в Ubuntu брандмауэр настроен на разрешение любого трафика. Если мы настраиваем наш кластер в тестовой среде, настройка брандмауэра не обязательна.</p>
<ol>
<li>На мастер-ноде (Control-plane)
Выполняем команду:</li>
</ol>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> iptables -I INPUT <span class="token number">1</span> -p tcp --match multiport --dports <span class="token number">6443,2379</span>:2380,10250:10252 -j ACCEPT
</span></code></pre>
<p>в данном примере мы открываем следующие порты:</p>
<ul>
<li>6443 — подключение для управления (Kubernetes API).</li>
<li>2379:2380 — порты для взаимодействия мастера с воркерами (etcd server client API).</li>
<li>10250:10252 — работа с kubelet (соответственно API, scheduler, controller-manager).
Для сохранения правил выполняем команду:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> netfilter-persistent save
</span></code></pre>
<ol start="2">
<li>На рабочей ноде (Worker):
На нодах для контейнеров открываем такие порты:</li>
</ol>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> iptables -I INPUT <span class="token number">1</span> -p tcp --match multiport --dports <span class="token number">10250,30000</span>:32767 -j ACCEPT
</span></code></pre>
<p>где:</p>
<ul>
<li>10250 — подключение к kubelet API.</li>
<li>30000:32767 — рабочие порты по умолчанию для подключения к подам (NodePort Services).
Сохраняем правила командой:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> netfilter-persistent save
</span></code></pre>
<h2 id="установка-и-настройка-docker" class="heading">Установка и настройка Docker</h2>
<p>На все узлы кластера выполняем установку Docker следующей командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">docker</span> docker.io
</span></code></pre>
<p>После установки разрешаем автозапуск сервиса docker:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>
</span></code></pre>
<p>Создаем файл:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">vi</span> /etc/docker/daemon.json
</span><span class="code-line">
</span><span class="code-line"><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token string">"exec-opts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"native.cgroupdriver=systemd"</span><span class="token punctuation">]</span>,
</span><span class="code-line">  <span class="token string">"log-driver"</span><span class="token builtin class-name">:</span> <span class="token string">"json-file"</span>,
</span><span class="code-line">  <span class="token string">"log-opts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token string">"max-size"</span><span class="token builtin class-name">:</span> <span class="token string">"100m"</span>
</span><span class="code-line">  <span class="token punctuation">}</span>,
</span><span class="code-line">  <span class="token string">"storage-driver"</span><span class="token builtin class-name">:</span> <span class="token string">"overlay2"</span>,
</span><span class="code-line">  <span class="token string">"storage-opts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
</span><span class="code-line">    <span class="token string">"overlay2.override_kernel_check=true"</span>
</span><span class="code-line">  <span class="token punctuation">]</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>для нас является важной настройкой <em>cgroupdriver</em> — она должна быть выставлена в значение systemd. В противном случае, при создании кластера Kubernetes выдаст предупреждение. Хоть на возможность работы последнего это не влияет, но мы постараемся выполнить развертывание без ошибок и предупреждений со стороны системы. Перезапускаем docker:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> systemctl restart <span class="token function">docker</span>
</span></code></pre>
<h2 id="установка-kubernetes" class="heading">Установка Kubernetes</h2>
<ul>
<li>Установку необходимых компонентов выполним из репозитория. Добавим его ключ для цифровой подписи:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">curl</span> -s https://packages.cloud.google.com/apt/doc/apt-key.gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -
</span></code></pre>
<ul>
<li>Создадим файл с настройкой репозитория:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">vi</span> /etc/apt/sources.list.d/kubernetes.list
</span><span class="code-line">
</span><span class="code-line">deb https://apt.kubernetes.io/ kubernetes-xenial main
</span></code></pre>
<ul>
<li>Обновим список пакетов:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">apt-get</span> update
</span></code></pre>
<ul>
<li>Устанавливаем пакеты:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> kubelet kubeadm kubectl
</span></code></pre>
<p>где:</p>
<ul>
<li><strong>kubelet</strong> — сервис, который запускается и работает на каждом узле кластера. Следит за работоспособностью подов.</li>
<li><strong>kubeadm</strong> — утилита для управления кластером Kubernetes.</li>
<li><strong>kubectl</strong> — утилита для отправки команд кластеру Kubernetes.
Нормальная работа кластера сильно зависит от версии установленных пакетов. Поэтому бесконтрольное их обновление может привести к потере работоспособности всей системы. Чтобы этого не произошло, запрещаем обновление установленных компонентов:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> apt-mark hold kubelet kubeadm kubectl
</span></code></pre>
<p>Установка завершена — можно запустить команду:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl version --client
</span></code></pre>
<p>Мы увидим установленную версию программы:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">Client Version: version.Info<span class="token punctuation">{</span>Major:<span class="token string">"1"</span>, Minor:<span class="token string">"20"</span>, GitVersion:<span class="token string">"v1.20.2"</span>, GitCommit:<span class="token string">"faecb196815e248d3ecfb03c680a4507229c2a56"</span>, GitTreeState:<span class="token string">"clean"</span>, BuildDate:<span class="token string">"2021-01-13T13:28:09Z"</span>, GoVersion:<span class="token string">"go1.15.5"</span>, Compiler:<span class="token string">"gc"</span>, Platform:<span class="token string">"linux/amd64"</span><span class="token punctuation">}</span>
</span></code></pre>
<p>Наши серверы готовы к созданию кластера.</p>
<h2 id="создание-кластера" class="heading">Создание кластера</h2>
<p>По-отдельности, рассмотрим процесс настройки мастер ноды (control-plane) и присоединения к ней двух рабочих нод (worker).</p>
<p>Настройка control-plane (мастер ноды)
Выполняем команду на мастер ноде:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubeadm init --pod-network-cidr<span class="token operator">=</span><span class="token number">10.244</span>.0.0/16
</span></code></pre>
<p>данная команда выполнит начальную настройку и подготовку основного узла кластера. Ключ <em>--pod-network-cidr</em> задает адрес внутренней подсети для нашего кластера. Выполнение займет несколько минут, после чего мы увидим что-то на подобие:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token punctuation">..</span>.
</span><span class="code-line">Then you can <span class="token function">join</span> any number of worker nodes by running the following on each as root:
</span><span class="code-line">
</span><span class="code-line">kubeadm <span class="token function">join</span> <span class="token number">192.168</span>.0.15:6443 --token f7sihu.wmgzwxkvbr8500al <span class="token punctuation">\</span>
</span><span class="code-line">    --discovery-token-ca-cert-hash sha256:6746f66b2197ef496192c9e240b31275747734cf74057e04409c33b1ad280321
</span></code></pre>
<p>данную команду нужно вводить на worker нодах, чтобы присоединить их к нашему кластеру. Можно ее скопировать, но позже мы будем генерировать данную команду по новой. В окружении пользователя создаем переменную KUBECONFIG, с помощью которой будет указан путь до файла конфигурации kubernetes:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBECONFIG</span><span class="token operator">=</span>/etc/kubernetes/admin.conf
</span></code></pre>
<p>Чтобы каждый раз при входе в систему не приходилось повторять данную команду, открываем файл:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">vi</span> /etc/environment
</span></code></pre>
<p>И добавляем в него строку:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBECONFIG</span><span class="token operator">=</span>/etc/kubernetes/admin.conf
</span></code></pre>
<p>Посмотреть список узлов кластера можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl get nodes
</span></code></pre>
<p>На данном этапе мы должны увидеть только мастер ноду:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">NAME                      STATUS     ROLES                  AGE   VERSION
</span><span class="code-line">k8s-master.server.local    NotReady   <span class="token operator">&#x3C;</span>none<span class="token operator">></span>                 10m   v1.20.2
</span></code></pre>
<p>Чтобы завершить настройку, необходимо установить CNI (Container Networking Interface) — в моем примере это flannel:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
</span></code></pre>
<p>Узел управления кластером готов к работе.</p>
<h2 id="настройка-worker-рабочей-ноды" class="heading">Настройка worker (рабочей ноды)</h2>
<p>Мы можем использовать команду для присоединения рабочего узла, которую мы получили после инициализации мастер ноды или вводим (на первом узле):</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubeadm token create --print-join-command
</span></code></pre>
<p>Данная команда покажет нам запрос на присоединения новой ноды к кластеру, например:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">kubeadm <span class="token function">join</span> <span class="token number">192.168</span>.0.15:6443 --token f7sihu.wmgzwxkvbr8500al <span class="token punctuation">\</span>
</span><span class="code-line">    --discovery-token-ca-cert-hash sha256:6746f66b2197ef496192c9e240b31275747734cf74057e04409c33b1ad280321
</span></code></pre>
<p>Копируем его и используем на двух наших узлах. После завершения работы команды, мы должны увидеть:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">Run <span class="token string">'kubectl get nodes'</span> on the control-plane to see this <span class="token function">node</span> <span class="token function">join</span> the cluster.
</span></code></pre>
<p>На мастер ноде вводим:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl get nodes
</span></code></pre>
<p>Мы должны увидеть:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">NAME                      STATUS   ROLES                  AGE   VERSION
</span><span class="code-line">k8s-master1.server.local   Ready    control-plane,master   18m   v1.20.2
</span><span class="code-line">k8s-worker1.server.local   Ready    <span class="token operator">&#x3C;</span>none<span class="token operator">></span>                 79s   v1.20.2
</span><span class="code-line">k8s-worker2.server.local   Ready    <span class="token operator">&#x3C;</span>none<span class="token operator">></span>                 77s   v1.20.2
</span></code></pre>
<p>Наш кластер готов к работе. Теперь можно создавать поды, развертывания и службы. Рассмотрим эти процессы подробнее.</p>
<h2 id="pods" class="heading">Pods</h2>
<p><em>Поды</em> — неделимая сущность объекта в Kubernetes. Каждый Pod может включать в себя несколько контейнеров (минимум, 1). Рассмотрим несколько примеров, как работать с подами. Все команды выполняем на мастере.
<strong>Создание</strong>
Поды создаются командой kubectl, например:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl run nginx --image<span class="token operator">=</span>nginx:latest --port<span class="token operator">=</span><span class="token number">80</span>
</span></code></pre>
<p>в данном примере мы создаем под с названием nginx, который в качестве образа Docker будет использовать nginx (последнюю версию); также наш под будет слушать запросы на порту 80.
Чтобы получить сетевой доступ к созданному поду, создаем port-forward следующей командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl port-forward nginx --address <span class="token number">0.0</span>.0.0 <span class="token number">8888</span>:80
</span></code></pre>
<p>в данном примере запросы к кластеру kubernetes на порт 8888 будут вести на порт 80 (который мы использовали для нашего пода).
Команда <em>kubectl port-forward</em> является интерактивной. Ее мы используем только для тестирования. Чтобы пробросить нужные порты в Kubernetes используются Services — об этом будет сказано ниже.
Можно открыть браузер и ввести адрес <em>http://&#x3C;IP-адрес мастера>:8888</em> — должна открыться страница приветствия для NGINX.
<strong>Просмотр</strong>
Получить список всех подов в кластере можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">kubectl get pods
</span></code></pre>
<p>Например, в нашем примере мы должны увидеть что-то на подобие:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">NAME    READY   STATUS    RESTARTS   AGE
</span><span class="code-line">nginx   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          3m26s
</span></code></pre>
<p>Посмотреть подробную информацию о конкретном поде можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">kubectl describe pods nginx
</span></code></pre>
<p>Запуск команд внутри контейнера
Мы можем запустить одну команду в контейнере, например, такой командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">kubectl <span class="token builtin class-name">exec</span> nginx -- <span class="token function">date</span>
</span></code></pre>
<p>в данном примере будет запущена команда date внутри контейнера nginx.
Также мы можем подключиться к командной строке контейнера командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">kubectl <span class="token builtin class-name">exec</span> --tty --stdin nginx -- /bin/bash
</span></code></pre>
<p><strong>Удаление</strong>
Для удаления пода вводим:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl delete pods nginx
</span></code></pre>
<h2 id="использование-манифестов" class="heading">Использование манифестов</h2>
<p>В продуктивной среде управление подами выполняется с помощью специальных файлов с описанием того, как должен создаваться и настраиваться под — манифестов. Рассмотрим пример создания и применения такого манифеста.
Создадим файл формата yml:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">vi</span> manifest_pod.yaml
</span><span class="code-line">
</span><span class="code-line">apiVersion: v1
</span><span class="code-line">kind: Pod
</span><span class="code-line">metadata: 
</span><span class="code-line">  name: web-srv
</span><span class="code-line">  labels:
</span><span class="code-line">    app: web_server
</span><span class="code-line">    owner: dmosk
</span><span class="code-line">    description: web_server_for_site
</span><span class="code-line">spec:
</span><span class="code-line">  containers: 
</span><span class="code-line">    - name: nginx
</span><span class="code-line">      image: nginx:latest
</span><span class="code-line">      ports:
</span><span class="code-line">        - containerPort: <span class="token number">80</span>
</span><span class="code-line">        - containerPort: <span class="token number">443</span>
</span><span class="code-line">
</span><span class="code-line">    - name: php-fpm
</span><span class="code-line">      image: php-fpm:latest
</span><span class="code-line">      ports:
</span><span class="code-line">        - containerPort: <span class="token number">9000</span>
</span><span class="code-line">
</span><span class="code-line">    - name: mariadb
</span><span class="code-line">      image: mariadb:latest
</span><span class="code-line">      ports:
</span><span class="code-line">        - containerPort: <span class="token number">3306</span>
</span></code></pre>
<p>в данном примере будет создан под с названием web-srv; в данном поде будет развернуто 3 контейнера — <em>nginx</em>, <em>php-fpm</em> и <em>mariadb</em> на основе одноименных образов.
Для объектов Kubernetes очень важное значение имеют метки или <em>labels</em>. Необходимо всегда их описывать. Далее, данные метки могут использоваться для настройки сервисов и развертываний.
Чтобы применить манифест выполняем команду:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl apply -f manifest_pod.yaml
</span></code></pre>
<p>Мы должны увидеть ответ:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">pod/web-srv created
</span></code></pre>
<p>Смотрим поды командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl get pods
</span></code></pre>
<p>Мы должны увидеть:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">NAME      READY   STATUS    RESTARTS   AGE
</span><span class="code-line">web-srv   <span class="token number">3</span>/3     Ready     <span class="token number">0</span>          3m11s
</span></code></pre>
<p>для <em>Ready</em> мы можем увидеть 0/3 или 1/3 — это значит, что контейнеры внутри пода еще создаются и нужно подождать.</p>
<h2 id="deployments" class="heading">Deployments</h2>
<p>Развертывания позволяют управлять экземплярами подов. С их помощью контролируется их восстановление, а также балансировка нагрузки. Рассмотрим пример использования Deployments в Kubernetes.
<strong>Создание</strong>
<em>Deployment</em> создаем командой со следующим синтаксисом:
<em>kubectl create deploy &#x3C;название для развертывания> --image &#x3C;образ, который должен использоваться></em>
Например:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">kubectl create deploy web-set --image nginx:latest
</span></code></pre>
<p>данной командой мы создадим deployment с именем web-set; в качестве образа будем использовать nginx:latest.
<strong>Просмотр</strong>
Посмотреть список развертываний можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl get deploy
</span></code></pre>
<p>Подробное описание для конкретного развертывания мы можем посмотреть так:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl describe deploy web-set
</span></code></pre>
<p>в данном примере мы посмотрим описание deployment с названием web-set.</p>
<h2 id="scaling" class="heading">Scaling</h2>
<p>Как было написано выше, deployment может балансировать нагрузкой. Это контролируется параметром <em>scaling</em>:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">kubectl scale deploy web-set --replicas <span class="token number">3</span>
</span></code></pre>
<p>в данном примере мы указываем для нашего созданного ранее deployment использовать 3 реплики — то есть Kubernetes создаст 3 экземпляра контейнеров.
Также мы можем настроить автоматическую балансировку:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl autoscale deploy web-set --min<span class="token operator">=</span><span class="token number">5</span> --max<span class="token operator">=</span><span class="token number">10</span> --cpu-percent<span class="token operator">=</span><span class="token number">75</span>
</span></code></pre>
<p>В данном примере Kubernetes будет создавать от 5 до 10 экземпляров контейнеров — добавление нового экземпляра будет происходить при превышении нагрузки на процессор до 75% и более.
Посмотреть созданные параметры балансировки можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl get hpa
</span></code></pre>
<p><strong>Редактирование</strong>
Для нашего развертывания мы можем изменить используемый образ, например:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl <span class="token builtin class-name">set</span> image deploy/web-set <span class="token assign-left variable">nginx</span><span class="token operator">=</span>httpd:latest --record
</span></code></pre>
<p>данной командой для <em>deployment web-set</em> мы заменим образ nginx на httpd, а ключ <em>record</em> позволит нам записать действие в историю изменений.
Если мы использовали ключ <em>record</em>, то историю изменений можно посмотреть командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl rollout <span class="token function">history</span> deploy/web-set
</span></code></pre>
<p>Перезапустить <em>deployment</em> можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl rollout restart deploy web-set
</span></code></pre>
<h2 id="манифесты" class="heading">Манифесты</h2>
<p>Как в случае с подами, для создания развертываний мы можем использовать манифесты. Попробуем рассмотреть конкретный пример.
<strong>Создание</strong>
Создаем новый файл:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">vi</span> manifest_deploy.yaml
</span><span class="code-line">
</span><span class="code-line">apiVersion: apps/v1
</span><span class="code-line">kind: Deployment
</span><span class="code-line">metadata:
</span><span class="code-line">  name: web-deploy
</span><span class="code-line">  labels:
</span><span class="code-line">    app: web_server
</span><span class="code-line">    owner: dmosk
</span><span class="code-line">    description: web_server_for_site
</span><span class="code-line">spec:
</span><span class="code-line">  replicas: <span class="token number">5</span>
</span><span class="code-line">  selector:
</span><span class="code-line">    matchLabels:
</span><span class="code-line">      project: myweb
</span><span class="code-line">  template:
</span><span class="code-line">    metadata:
</span><span class="code-line">      labels:
</span><span class="code-line">        project: myweb
</span><span class="code-line">        owner: dmosk
</span><span class="code-line">        description: web_server_pod
</span><span class="code-line">    spec:
</span><span class="code-line">      containers:
</span><span class="code-line">        - name: myweb-httpd
</span><span class="code-line">          image: httpd:latest
</span><span class="code-line">          ports:
</span><span class="code-line">            - containerPort: <span class="token number">80</span>
</span><span class="code-line">            - containerPort: <span class="token number">443</span>
</span><span class="code-line">            
</span><span class="code-line">---
</span><span class="code-line">apiVersion: autoscaling/v2beta2
</span><span class="code-line">kind: HorizontalPodAutoscaler
</span><span class="code-line">metadata:
</span><span class="code-line">  name: web-deploy-autoscaling
</span><span class="code-line">spec:
</span><span class="code-line">  scaleTargetRef:
</span><span class="code-line">    apiVersion: apps/v1
</span><span class="code-line">    kind: Deployment
</span><span class="code-line">    name: myweb-autoscaling
</span><span class="code-line">  minReplicas: <span class="token number">5</span>
</span><span class="code-line">  maxReplicas: <span class="token number">10</span>
</span><span class="code-line">  metrics:
</span><span class="code-line">  - type: Resource
</span><span class="code-line">    resource:
</span><span class="code-line">      name: cpu
</span><span class="code-line">      target:
</span><span class="code-line">        type: Utilization
</span><span class="code-line">        averageUtilization: <span class="token number">75</span>
</span><span class="code-line">  - type: Resource
</span><span class="code-line">    resource:
</span><span class="code-line">      name: memory
</span><span class="code-line">      target:
</span><span class="code-line">        type: Utilization
</span><span class="code-line">        averageUtilization: <span class="token number">80</span>
</span></code></pre>
<p>в данном манифесте мы создадим <em>deployment</em> и <em>autoscaling</em>. Итого, мы получим 5 экземпляров подов для развертывания web-deploy, которые могут быть расширены до 10 экземпляров. Добавление нового будет происходить при превышении нагрузки на процессор более чем на 75% или потреблением оперативной памяти более чем на 80%.
Чтобы создать объекты с помощью нашего манифеста вводим:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl apply -f manifest_deploy.yaml
</span></code></pre>
<p>Мы должны увидеть:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">deployment.apps/web-deploy created
</span><span class="code-line">horizontalpodautoscaler.autoscaling/web-deploy-autoscaling created
</span></code></pre>
<p>Объекты <em>web-deploy</em> и <em>web-deploy-autoscaling</em> созданы.
<strong>Удаление</strong>
Для удаления конкретного развертывания используем команду:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl delete deploy web-set
</span></code></pre>
<p>Для удаления всех развертываний вместо названия deployment указываем ключ --all:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl delete deploy --all
</span></code></pre>
<p>Удалить критерии autoscaling для конкретного развертывания можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl delete hpa web-set
</span></code></pre>
<p>Удалить все критерии autoscaling можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl delete hpa --all
</span></code></pre>
<p>Удалить объекты, созданные с помощью манифеста можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl delete -f manifest_deploy.yaml
</span></code></pre>
<h2 id="services" class="heading">Services</h2>
<p><strong>Службы</strong> позволяют обеспечить сетевую доступность для развертываний. Существует несколько типов сервисов:</p>
<ul>
<li><strong>ClusterIP</strong> — сопоставление адреса с deployments для подключений внутри кластера Kubernetes.</li>
<li><strong>NodePort</strong> — для внешней публикации развертывания.</li>
<li><strong>LoadBalancer</strong> — сопоставление через внешний балансировщик.</li>
<li><strong>ExternalName</strong> — сопоставляет службу по имени (возвращает значение записи CNAME).
Мы рассмотрим первые два варианта.</li>
</ul>
<h2 id="привязка-к-deployments" class="heading">Привязка к Deployments</h2>
<p>Попробуем создать сопоставления для ранее созданного развертывания:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">kubectl expose deploy web-deploy --type<span class="token operator">=</span>ClusterIP --port<span class="token operator">=</span><span class="token number">80</span>
</span></code></pre>
<p>где <em>web-deploy</em> — deployment, который мы развернули с помощью манифеста. Публикация ресурса происходит на внутреннем порту 80. Обращаться к контейнерам можно внутри кластера Kubernetes.
Для создания сопоставления, с помощью которого можно будет подключиться к контейнерам из внешней сети выполняется командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl expose deploy web-deploy --type<span class="token operator">=</span>NodePort --port<span class="token operator">=</span><span class="token number">80</span>
</span></code></pre>
<p>данная команда отличается от команды выше только типом NodePort — для данному deployment будет сопоставлен порт для внешнего подключения, который будет вести на внутренний (в нашем примере, 80).
<strong>Просмотр</strong>
Чтобы посмотреть созданные нами службы, вводим:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">kubectl get services
</span></code></pre>
<p>Мы можем увидеть что-то на подобие:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>        AGE
</span><span class="code-line">web-deploy   NodePort    <span class="token number">10.111</span>.229.132   <span class="token operator">&#x3C;</span>none<span class="token operator">></span>        <span class="token number">80</span>:30929/TCP   21s
</span></code></pre>
<p>в данном примере указано, что у нас есть служба типа <em>NodePort</em>, а к сервису можно подключиться по порту 30929.
Можно попробовать открыть браузер и ввести <em>http://&#x3C;IP-адрес мастера>:30929</em> — мы должны увидеть нужную нам страницу (в наших примерах, либо NGINX, либо Apache).
<strong>Просмотр</strong>
Посмотреть список сервисов с указанием селектором можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl get services -o wide
</span></code></pre>
<p><strong>Удаление</strong>
Удаляем созданную службу командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl delete services web-deploy
</span></code></pre>
<p>в данном примере будет удалена служба для развертывания web-deploy.
Удалить все службы можно командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl delete services --all
</span></code></pre>
<p>** Манифест **
Как в случае с подами и развертываниями, мы можем использовать манифест-файлы. Рассмотрим небольшой пример.</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">vi</span> manifest_service.yaml
</span><span class="code-line">
</span><span class="code-line">apiVersion: v1
</span><span class="code-line">kind: Service
</span><span class="code-line">metadata:
</span><span class="code-line">  name: web-service
</span><span class="code-line">  labels:
</span><span class="code-line">    app: web_server
</span><span class="code-line">    owner: dmosk
</span><span class="code-line">    description: web_server_for_site
</span><span class="code-line">spec:
</span><span class="code-line">  selector:
</span><span class="code-line">    project: myweb
</span><span class="code-line">  type: NodePort
</span><span class="code-line">  ports:
</span><span class="code-line">    - name: app-http
</span><span class="code-line">      protocol: TCP
</span><span class="code-line">      port: <span class="token number">80</span>
</span><span class="code-line">      targetPort: <span class="token number">80</span>
</span><span class="code-line">
</span><span class="code-line">    - name: app-smtp
</span><span class="code-line">      protocol: TCP
</span><span class="code-line">      port: <span class="token number">25</span>
</span><span class="code-line">      targetPort: <span class="token number">25</span>
</span></code></pre>
<p>в данном примере мы создадим службу, которая будем связываться с развертыванием по лейболу project: myweb.</p>
<h2 id="ingress-controller" class="heading">Ingress Controller</h2>
<p>В данной инструкции не будет рассказано о работе с Ingress Controller. Оставляем данный пункт для самостоятельного изучения.
Данное приложение позволяет создать балансировщик, распределяющий сетевые запросы между нашими сервисами. Порядок обработки сетевого трафика определяем с помощью Ingress Rules.
Существует не маленькое количество реализаций Ingress Controller — их сравнение можно найти в документе по ссылке в Google Docs.
Для установки Ingress Controller Contour (среди множества контроллеров, он легко устанавливается и на момент обновления данной инструкции полностью поддерживает последнюю версию кластера Kubernetes) вводим:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl apply -f https://projectcontour.io/quickstart/contour.yaml
</span></code></pre>
<p><strong>Установка веб-интерфейса</strong>
Веб-интерфейс позволяет получить информацию о работе кластера в удобном для просмотра виде.
В большинстве инструкций рассказано, как получить доступ к веб-интерфейсу с того же компьютера, на котором находится кластер (по адресу 127.0.0.1 или localhost). Но мы рассмотрим настройку для удаленного подключения, так как это более актуально для серверной инфраструктуры.</p>
<ul>
<li>Переходим на страницу веб-интерфейса в GitHub и копируем ссылку на последнюю версию файла yaml.
Копируем ссылку на конфигурационный файл для создания панели управления Kubernetes, на момент обновления инструкции, последняя версия интерфейса была 2.1.0.</li>
<li>Скачиваем yaml-файл командой:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$wget</span> https://raw.githubusercontent.com/kubernetes/dashboard/v2.1.0/aio/deploy/recommended.yaml
</span></code></pre>
<p>где <a href="https://raw.githubusercontent.com/kubernetes/dashboard/v2.1.0/aio/deploy/recommended.yaml" target="_blank" rel="noopener noreferer">https://raw.githubusercontent.com/kubernetes/dashboard/v2.1.0/aio/deploy/recommended.yaml</a> — ссылка, которую мы скопировали на портале GitHub.</p>
<ul>
<li>Открываем на редактирование скачанный файл:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$vi</span> recommended.yaml
</span></code></pre>
<p>Комментируем строки для kind: Namespace и kind: Secret (в файле несколько блоков с kind: Secret — нам нужен тот, что с name: kubernetes-dashboard-certs):</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token punctuation">..</span>.
</span><span class="code-line"><span class="token comment">#apiVersion: v1</span>
</span><span class="code-line"><span class="token comment">#kind: Namespace</span>
</span><span class="code-line"><span class="token comment">#metadata:</span>
</span><span class="code-line"><span class="token comment">#  name: kubernetes-dashboard</span>
</span><span class="code-line"><span class="token punctuation">..</span>.
</span><span class="code-line"><span class="token comment">#apiVersion: v1</span>
</span><span class="code-line"><span class="token comment">#kind: Secret</span>
</span><span class="code-line"><span class="token comment">#metadata:</span>
</span><span class="code-line"><span class="token comment">#  labels:</span>
</span><span class="code-line"><span class="token comment">#    k8s-app: kubernetes-dashboard</span>
</span><span class="code-line"><span class="token comment">#  name: kubernetes-dashboard-certs</span>
</span><span class="code-line"><span class="token comment">#  namespace: kubernetes-dashboard</span>
</span><span class="code-line"><span class="token comment">#type: Opaque</span>
</span></code></pre>
<p>нам необходимо закомментировать эти блоки, так как данные настройки в Kubernetes мы должны будем сделать вручную.
Теперь в том же файле находим kind: Service (который с name: kubernetes-dashboard) и добавляем строки type: NodePort и nodePort: 30001 (выделены красным):</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">kind: Service
</span><span class="code-line">apiVersion: v1
</span><span class="code-line">metadata:
</span><span class="code-line">  labels:
</span><span class="code-line">    k8s-app: kubernetes-dashboard
</span><span class="code-line">  name: kubernetes-dashboard
</span><span class="code-line">  namespace: kubernetes-dashboard
</span><span class="code-line">spec:
</span><span class="code-line">  type: NodePort
</span><span class="code-line">  ports:
</span><span class="code-line">    - port: <span class="token number">443</span>
</span><span class="code-line">      targetPort: <span class="token number">8443</span>
</span><span class="code-line">      nodePort: <span class="token number">30001</span>
</span><span class="code-line">  selector:
</span><span class="code-line">    k8s-app: kubernetes-dashboard
</span></code></pre>
<p>таким образом, мы публикуем наш сервис на внешнем адресе и порту 30001.
Для подключения к веб-интерфейсу не через локальный адрес, начиная с версии 1.17, обязательно необходимо использовать зашифрованное подключение (https). Для этого нужен сертификат. В данной инструкции мы сгенерируем самоподписанный сертификат — данный подход удобен для тестовой среды, но в продуктивной среде необходимо купить сертификат или получить его бесплатно в Let's Encrypt.
И так, создаем каталог, куда разместим наши сертификаты:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">mkdir</span> -p /etc/ssl/kubernetes
</span></code></pre>
<p>Сгенерируем сертификаты командой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> openssl req -new -x509 -days <span class="token number">1461</span> -nodes -out /etc/ssl/kubernetes/cert.pem -keyout /etc/ssl/kubernetes/cert.key -subj <span class="token string">"/C=RU/ST=SPb/L=SPb/O=Global Security/OU=IT Department/CN=kubernetes.dmosk.local/CN=kubernetes"</span>
</span></code></pre>
<p>можно не менять параметры команды, а так их и оставить. Браузер все-равно будет выдавать предупреждение о неправильном сертификате, так как он самоподписанный.
<strong>Создаем namespace</strong></p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl create namespace kubernetes-dashboard
</span></code></pre>
<p>это та первая настройка, которую мы комментировали в скачанном файле recommended.yaml.
Теперь создаем настройку для secret с использованием наших сертификатов:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl create secret generic kubernetes-dashboard-certs --from-file<span class="token operator">=</span>/etc/ssl/kubernetes/cert.key --from-file<span class="token operator">=</span>/etc/ssl/kubernetes/cert.pem -n kubernetes-dashboard
</span></code></pre>
<p>собственно, мы не использовали настройку в скачанном файле, так как создаем ее с включением в параметры пути до созданных нами сертификатов.
Теперь создаем остальные настройки с помощью скачанного файла:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl create -f recommended.yaml
</span></code></pre>
<p>Мы увидим что-то на подобие:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">serviceaccount/kubernetes-dashboard created
</span><span class="code-line">service/kubernetes-dashboard created
</span><span class="code-line">secret/kubernetes-dashboard-csrf created
</span><span class="code-line">secret/kubernetes-dashboard-key-holder created
</span><span class="code-line">configmap/kubernetes-dashboard-settings created
</span><span class="code-line">role.rbac.authorization.k8s.io/kubernetes-dashboard created
</span><span class="code-line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created
</span><span class="code-line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created
</span><span class="code-line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created
</span><span class="code-line">deployment.apps/kubernetes-dashboard created
</span><span class="code-line">service/dashboard-metrics-scraper created
</span><span class="code-line">deployment.apps/dashboard-metrics-scraper created
</span></code></pre>
<p>Создадим настройку для админского подключения:</p>
<pre><code class="code-highlight"><span class="code-line">$sudo vi dashboard-admin.yaml
</span><span class="code-line">
</span><span class="code-line">apiVersion: v1
</span><span class="code-line">kind: ServiceAccount
</span><span class="code-line">metadata:
</span><span class="code-line">  labels:
</span><span class="code-line">    k8s-app: kubernetes-dashboard
</span><span class="code-line">  name: dashboard-admin
</span><span class="code-line">  namespace: kubernetes-dashboard
</span><span class="code-line">
</span><span class="code-line">---
</span><span class="code-line">apiVersion: rbac.authorization.k8s.io/v1
</span><span class="code-line">kind: ClusterRoleBinding
</span><span class="code-line">metadata:
</span><span class="code-line">  name: dashboard-admin-bind-cluster-role
</span><span class="code-line">  labels:
</span><span class="code-line">    k8s-app: kubernetes-dashboard
</span><span class="code-line">roleRef:
</span><span class="code-line">  apiGroup: rbac.authorization.k8s.io
</span><span class="code-line">  kind: ClusterRole
</span><span class="code-line">  name: cluster-admin
</span><span class="code-line">subjects:
</span><span class="code-line">- kind: ServiceAccount
</span><span class="code-line">  name: dashboard-admin
</span><span class="code-line">  namespace: kubernetes-dashboard
</span></code></pre>
<p>Создаем настройку с применением созданного файла:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl create -f dashboard-admin.yaml
</span></code></pre>
<p>Теперь открываем браузер и переходим по ссылке <em>https://&#x3C;IP-адрес мастера>:30001</em> — браузер покажет ошибку сертификата (если мы настраиваем по инструкции и сгенерировали самоподписанный сертификат). Игнорируем ошибку и продолжаем загрузку.
<em>Kubernetes Dashboard</em> потребует пройти проверку подлинности. Для этого можно использовать токен или конфигурационный файл.
На сервере вводим команду для создания сервисной учетной записи:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl create serviceaccount dashboard-admin -n kube-system
</span></code></pre>
<p>Создадим привязку нашего сервисного аккаунта с Kubernetes Dashboard:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl create clusterrolebinding dashboard-admin --clusterrole<span class="token operator">=</span>cluster-admin --serviceaccount<span class="token operator">=</span>kube-system:dashboard-admin
</span></code></pre>
<p>Теперь камандой:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl describe secrets -n kube-system <span class="token variable"><span class="token variable">$(</span>kubectl -n kube-system get secret <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'/dashboard-admin/{print $1}'</span><span class="token variable">)</span></span>
</span></code></pre>
<p>... получаем токен для подключения:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">Data
</span><span class="code-line"><span class="token operator">==</span><span class="token operator">==</span>
</span><span class="code-line">ca.crt:     <span class="token number">1066</span> bytes
</span><span class="code-line">namespace:  <span class="token number">11</span> bytes
</span><span class="code-line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IkpCT0J5TWF2VWxWQUotdHZYclFUaWwza2NfTW1IZVNuSlZSN3hWUzFrNTAifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4tbnRqNmYiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiMzIwNjVhYmQtNzAwYy00Yzk5LThmZjktZjc0YjM5MTU0Y2VhIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmRhc2hib2FyZC1hZG1pbiJ9.wvDGeNiTCRBakDplO6PbdqvPH_W2EsBgJjZnTDflneP3cdXQv6VgBkI8NalplXDRF-lF36KbbC2hpRjbkblrLW7BemIVWYOznmc8kmrgCSxO2FVi93NK3biE9TkDlj1BbdiyfOO86L56vteXGP20X0Xs1h3cjAshs-70bsnJl6z3MY5GbRVejOyVzq_PWMVYsqvQhssExsJM2tKJWG0DnXCW687XHistbYUolhxSRoRpMZk-JrguuwgLH5FYIIU-ZdTZA6mz-_hqrx8PoDvqEfWrsniM6Q0k8U3TMaDLlduzA7rwLRJBQt3C0aD6XfR9wHUqUWd5y953u67wpFPrSA
</span></code></pre>
<p>Используя полученный токен, вводим его в панели авторизации. Мы должны увидеть стартовое окно системы управления.</p>
<h2 id="удаление-нод" class="heading">Удаление нод</h2>
<p>При необходимости удалить ноду из нашего кластера, вводим 2 команды:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> kubectl drain k8s-worker2.server.local --ignore-daemonsets
</span><span class="code-line"><span class="token variable">$sudo</span> kubectl delete <span class="token function">node</span> k8s-worker2.server.local
</span></code></pre>
<p>в данном примере мы удаляем ноду k8s-worker2.server.local.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Установка стека LEMP на Ubuntu 20.04]]></title>
    <link>https://it-integ.ru/lemp</link>
    <pubDate>2022-08-22</pubDate>
    <guid isPermaLink="false">https://it-integ.ru/lemp</guid>
    <description>
    <![CDATA[Как установить Nginx, MySQL и PHP на Ubuntu 20.04]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>Стек LEMP</strong> – это группа программ, предназначенная для обслуживания динамических веб-страниц и веб-приложений. Этот акроним расшифровывается как Linux (операционная система), Nginx (веб-сервер), MySQL (система управления базами данных) и PHP (серверный язык сценариев для обработки динамического контента).</p>
<p>Данный мануал научит вас устанавливать все компоненты стека LEMP на сервер Ubuntu 20.04. Поскольку сервер использует операционную систему Ubuntu, первый компонент уже установлен. Мануал поможет вам установить остальное.</p>
<h2 id="требования" class="heading">Требования</h2>
<p>Для работы вам понадобится сервер Ubuntu 20.04</p>
<h2 id="1-установка-nginx" class="heading">1. Установка Nginx</h2>
<p>Для отображения веб-страниц в этом стеке используется производительный веб-сервер Nginx. Все программное обеспечение, необходимое для установки веб-сервера, находится в стандартных репозиториях системы, его можно установить с помощью пакетного менеджера apt.
Поскольку это первое взаимодействие с apt в текущей сессии, нужно обновить индекс пакетов. После этого можно установить Nginx.</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">apt</span> update
</span><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">apt</span> <span class="token function">install</span> nginx
</span></code></pre>
<p>По запросу подтвердите установку. После завершения установки в Ubuntu 20.04 Nginx запускается автоматически.
Если ранее вы включили брандмауэр ufw, сейчас нужно разблокировать в нем порты сервиса Nginx. Во время установки Nginx регистрирует профили в ufw, потому разрешить трафик веб-сервера очень просто.</p>
<p>Чтобы просмотреть доступные профили, введите:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> ufw app list
</span><span class="code-line">Available applications:
</span><span class="code-line">Nginx Full
</span><span class="code-line">Nginx HTTP
</span><span class="code-line">Nginx HTTPS
</span><span class="code-line">OpenSSH
</span></code></pre>
<p>Рекомендуется выбрать наиболее строгий профиль веб-сервера. Однако, поскольку на сервере ещё не настроен SSL, мы можем открыть только порт 80, за который отвечает профиль  Nginx HTTP.</p>
<p>Чтобы включить этот профиль, введите:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token function">sudo</span> ufw allow <span class="token string">'Nginx HTTP'</span>
</span></code></pre>
<p>Убедитесь в том, что он включился. Команда должна сообщить, что трафик HTTP разрешен:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> ufw status
</span><span class="code-line">
</span><span class="code-line">Status: active
</span><span class="code-line">To                         Action      From
</span><span class="code-line">--                         ------      ----
</span><span class="code-line">OpenSSH                    ALLOW       Anywhere
</span><span class="code-line">Nginx HTTP                 ALLOW       Anywhere
</span><span class="code-line">OpenSSH <span class="token punctuation">(</span>v6<span class="token punctuation">)</span>               ALLOW       Anywhere <span class="token punctuation">(</span>v6<span class="token punctuation">)</span>
</span><span class="code-line">Nginx HTTP <span class="token punctuation">(</span>v6<span class="token punctuation">)</span>            ALLOW       Anywhere <span class="token punctuation">(</span>v6<span class="token punctuation">)</span>
</span></code></pre>
<p>Добавив новое правило брандмауэра, можно проверить, работает ли сервер. Для этого попробуйте открыть стандартную посадочную страницу в браузере. Эта страница доступна по доменному имени или IP-адресу.
Если вы не знаете своего IP-адреса, вы можете узнать его с помощью командной строки. Введите:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$ip</span> addr show eth0 <span class="token operator">|</span> <span class="token function">grep</span> inet <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{ print $2; }'</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/\/.*$//'</span>
</span></code></pre>
<p>Команда вернёт несколько строк. Проверьте каждый адрес в браузере, чтобы найти тот, который работает для вашего сервера.</p>
<p>Также можно узнать, как ваш IP-адрес видят другие точки в сети. Для этого введите:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$curl</span> -4 icanhazip.com
</span></code></pre>
<p>Узнав вой IP, введите его в браузер, чтобы убедиться, что веб-сервер работает должным образом.</p>
<blockquote>
<p>http://server_domain_or_IP</p>
</blockquote>
<p>На экране должна появиться стандартная посадочная страница Nginx:</p>
<blockquote>
<p>Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p>
</blockquote>
<h2 id="2-установка-mysql" class="heading">2. Установка MySQL</h2>
<p>Теперь нужно установить MySQL, систему управления базами данных, которая будет хранить и систематизировать данные вашего сайта. MySQL – популярная СУБД в средах PHP.
Чтобы установить MySQL, используйте apt:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">apt</span> <span class="token function">install</span> mysql-server
</span></code></pre>
<p>После установки MySQL нужно защитить установку. Для этого можно запустить простой скрипт безопасности, который удалит потенциально опасные настройки. Запустите этот скрипт:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> mysql_secure_installation
</span></code></pre>
<p>Сначала он предложит настроить Validate Password Plugin, который проверяет надежность вашего пароля.
Примечание: Этот плагин оценивает сложность вашего пароля MySQL. Если пароль недостаточно сложный, он не пройдет проверку и будет отклонен с ошибкой. В целом этот плагин можно не включать, но вы должны всегда использовать надежные и уникальные пароли для защиты своих данных.
Если вы хотите включить этот плагин, введите Y:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">VALIDATE PASSWORD PLUGIN can be used to <span class="token builtin class-name">test</span> passwords
</span><span class="code-line">and improve security. It checks the strength of password
</span><span class="code-line">and allows the <span class="token function">users</span> to <span class="token builtin class-name">set</span> only those passwords <span class="token function">which</span> are
</span><span class="code-line">secure enough. Would you like to setup VALIDATE PASSWORD plugin?
</span><span class="code-line">Press y<span class="token operator">|</span>Y <span class="token keyword">for</span> Yes, any other key <span class="token keyword">for</span> No:
</span></code></pre>
<p>Если вы включили Validate Password Plugin, сценарий предложит выбрать уровень проверки пароля. Наивысший уровень можно включить, нажав 2; тогда ваш пароль должен будет включать минимум 8 символов, среди которых должны быть буквы в верхнем и нижне регистре, цифры и специальные символы.</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">There are three levels of password validation policy:
</span><span class="code-line">LOW    Length <span class="token operator">>=</span> <span class="token number">8</span>
</span><span class="code-line">MEDIUM Length <span class="token operator">>=</span> <span class="token number">8</span>, numeric, mixed case, and special characters
</span><span class="code-line">STRONG Length <span class="token operator">>=</span> <span class="token number">8</span>, numeric, mixed case, special characters and dictionary <span class="token function">file</span>
</span><span class="code-line">Please enter <span class="token number">0</span> <span class="token operator">=</span> LOW, <span class="token number">1</span> <span class="token operator">=</span> MEDIUM and <span class="token number">2</span> <span class="token operator">=</span> STRONG: <span class="token number">1</span>
</span></code></pre>
<p>Независимо от того, включили вы VALIDATE PASSWORD PLUGIN или нет, ваш сервер затем попросит вас выбрать и подтвердить пароль для пользователя root MySQL. Не путайте его с системным root. Root-пользователь базы данных – это администратор с полными привилегиями. Метод аутентификации root-пользователя MySQL по умолчанию не требует пароля, даже если пароль установлен; несмотря на это, вы должны определить здесь надежный пароль – в качестве дополнительной меры безопасности. Мы поговорим об этом чуть позже.</p>
<p>Если вы включили плагин проверки пароля, он оценит сложность выбранного вами пароля и спросит, хотите ли вы продолжить использовать его. Если вы довольны текущим паролем, введите Y в командной строке:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line">Estimated strength of the password: <span class="token number">100</span>
</span><span class="code-line">Do you wish to <span class="token builtin class-name">continue</span> with the password provided?<span class="token punctuation">(</span>Press y<span class="token operator">|</span>Y <span class="token keyword">for</span> Yes, any other key <span class="token keyword">for</span> No<span class="token punctuation">)</span> <span class="token builtin class-name">:</span> y
</span></code></pre>
<p>На остальные вопросы можно нажать Y и Enter. Это удалит анонимных пользователей и тестовые базы данных, отключит удалённый root логин и обновит текущие настройки MySQL.
После этого откройте командную строку MySQL в терминале:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> mysql
</span></code></pre>
<p>Вы подключитесь к серверу MySQL в качестве root пользователя базы данных. Вы должны увидеть примерно такой результат:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line">Welcome <span class="token keyword">to</span> the MySQL monitor<span class="token punctuation">.</span>  Commands <span class="token keyword">end</span> <span class="token keyword">with</span> <span class="token punctuation">;</span> <span class="token operator">or</span> \g<span class="token punctuation">.</span>
</span><span class="code-line">Your MySQL connection id <span class="token operator">is</span> <span class="token number">22</span>
</span><span class="code-line">Server version: <span class="token number">8.0</span><span class="token number">.19</span><span class="token operator">-</span><span class="token number">0</span>ubuntu5 <span class="token punctuation">(</span>Ubuntu<span class="token punctuation">)</span>
</span><span class="code-line">Copyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">2020</span><span class="token punctuation">,</span> Oracle <span class="token operator">and</span><span class="token operator">/</span><span class="token operator">or</span> its affiliates<span class="token punctuation">.</span> <span class="token keyword">All</span> rights reserved<span class="token punctuation">.</span>
</span><span class="code-line">Oracle <span class="token operator">is</span> a registered trademark <span class="token keyword">of</span> Oracle Corporation <span class="token operator">and</span><span class="token operator">/</span><span class="token operator">or</span> its
</span><span class="code-line">affiliates<span class="token punctuation">.</span> Other names may be trademarks <span class="token keyword">of</span> their respective
</span><span class="code-line">owners<span class="token punctuation">.</span>
</span><span class="code-line"><span class="token keyword">Type</span> <span class="token string">'help;'</span> <span class="token operator">or</span> <span class="token string">'\h'</span> <span class="token keyword">for</span> help<span class="token punctuation">.</span> <span class="token keyword">Type</span> <span class="token string">'\c'</span> <span class="token keyword">to</span> clear the <span class="token keyword">current</span> input statement<span class="token punctuation">.</span>
</span><span class="code-line">mysql<span class="token operator">></span>
</span></code></pre>
<p>Чтобы закрыть консоль MySQL, введите:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token operator">></span><span class="token keyword">exit</span>
</span></code></pre>
<p>Обратите внимание: вам не нужно было указывать пароль. Это потому, что метод аутентификации администратора по умолчанию в MySQL – unix_socket, а не password. Сначала такой метод может показаться проблемой безопасности, но он делает сервер базы данных более защищенным, поскольку войти в систему как пользователь root MySQL могут только системные пользователи с привилегиями sudo, подключающиеся из консоли или приложения с теми же привилегиями. Практически это значит, что вы не сможете использовать аккаунт администратора для подключения с вашего PHP-приложения.  Выбранный нами ранее root-пароль MySQL нужен на тот случай, если метод аутентификации unix_socket будет изменен на password.
Для повышения безопасности лучше иметь отдельные учетные записи с более узкими привилегиями для каждой базы данных (особенно если вы планируете разместить на своем сервере несколько БД).
Примечание: На момент написания этого мануала PHP-библиотека MySQL mysqlnd не поддерживает caching_sha2_authentication, метод аутентификации по умолчанию для MySQL 8. Потому при создании пользователей БД для приложений PHP на MySQL 8 вам необходимо убедиться, что они используют mysql_native_password. Мы поговорим об этом в разделе 6.
Теперь ваш сервер MySQL защищен. Далее мы установим PHP, последний компонент в стеке LAMP.</p>
<h2 id="3-установка-php" class="heading">3. Установка PHP</h2>
<p>PHP – это серверный язык сценариев для написания динамических страниц. Он позволяет запускать сценарии, подключаться к БД MySQL и передавать обработанный контент в браузер для отображения.
В отличие от Apache, Nginx поставляется без интерпретатора PHP. Nginx требуется внешняя программа для обработки PHP и соединения самого интерпретатора PHP с веб-сервером. Это позволяет повысить общую производительность большинства веб-сайтов на основе PHP, но требует дополнительной настройки.
Сейчас нужно установить php-fpm (fastCGI process manager). Так Nginx сможет передавать PHP-запросы на обработку.  Кроме того, вам понадобится php-mysql, модуль PHP, который позволяет PHP взаимодействовать с базами данных на основе MySQL. Базовые пакеты PHP будут автоматически установлены как зависимости.
Чтобы установить пакеты php-fpm и php-mysql, введите:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">apt</span> <span class="token function">install</span> php-fpm php-mysql
</span></code></pre>
<p>Вы установили все компоненты стека. Теперь нужно настроить работу Nginx и PHP.</p>
<h2 id="4-настройка-nginx-для-поддержки-php" class="heading">4. Настройка Nginx для поддержки PHP</h2>
<p>Чтобы настроить взаимодействие Nginx и PHP, нужно отредактировать блок server (виртуальный хост). Мы оставим конфигурацию Nginx по умолчанию без изменений, создадим новый файл конфигурации и новый корневой каталог для хранения файлов PHP. Файл конфигурации и каталог должен называться так же, как домен или хост, для которого он предназначен.
Примечание: В данном мануале мы используем условный домен <em>your_domain</em>, который вы должны заменить своим доменом.
В Ubuntu 20.04 Nginx поставляется с одним блоком server, он включен по умолчанию и настроен на обслуживание документов каталога <em>/var/www/html</em>. Это хорошо работает для одного сайта, но управлять несколькими сайтами так не получится. Вместо того чтобы изменять <em>/var/www/html</em>, создайте структуру каталогов в <em>/var/www</em>  для веб-сайта your_domain, оставив <em>/var/www/html</em> в качестве каталога по умолчанию, который будет обслуживаться, если запрос клиента не совпадает ни с одним другим сайтом.</p>
<p>Создайте корневой каталог для вашего домена:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">mkdir</span> /var/www/your_domain
</span></code></pre>
<p>Затем укажите владельца каталога с помощью переменной среды <em>$USER</em>, которая должна ссылаться на вашего текущего системного пользователя:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">chown</span> -R <span class="token environment constant">$USER</span><span class="token builtin class-name">:</span><span class="token environment constant">$USER</span> /var/www/your_domain
</span></code></pre>
<p>Откройте новый конфигурационный файл в каталоге sites-available:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">nano</span> /etc/nginx/sites-available/your_domain
</span></code></pre>
<p>Вы увидите пустой файл. Вставьте в него такие строки:</p>
<pre class="language-yml"><code class="language-yml code-highlight"><span class="code-line">server <span class="token punctuation">{</span>
</span><span class="code-line">  listen 80;
</span><span class="code-line">  server_name your_domain www.your_domain;
</span><span class="code-line">  root /var/www/your_domain;
</span><span class="code-line">  index index.html index.htm index.php;
</span><span class="code-line">  location / <span class="token punctuation">{</span>
</span><span class="code-line">    try_files $uri $uri/ =404;
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  location ~ \.php$ <span class="token punctuation">{</span>
</span><span class="code-line">    include snippets/fastcgi<span class="token punctuation">-</span>php.conf;
</span><span class="code-line">    fastcgi_pass unix<span class="token punctuation">:</span>/var/run/php/php7.4<span class="token punctuation">-</span>fpm.sock;
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  location ~ /\.ht <span class="token punctuation">{</span>
</span><span class="code-line">    deny all;
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>Вот что делает каждая директива:</p>
<ul>
<li><strong>listen</strong>: определяет порт. Который будет слушать Nginx (здесь это порт 80).</li>
<li><strong>root</strong>: определяет корневой каталог проекта, в котором должен храниться весь контент.
index: задает список, по которому Nginx сможет определить приоритет index файлов для этого сайта. Как правило, файлы <em>index.html</em> имеют более высокий приоритет, чем index.php, чтобы можно было быстро настроить целевую страницу обслуживания в приложениях PHP. Вы можете настроить эти параметры согласно потребностям вашего приложения.</li>
<li><strong>server_name</strong>: определяет доменные имена и/или IP-адреса, которые должен обслуживать этот блок server. В этой директиве укажите домен сервера или его внешний IP-адрес.</li>
<li><strong>location /</strong>: первый блок <em>location</em> включает в себя директиву <em>try_files</em>, которая проверяет наличие файлов или каталогов, соответствующих запросу URI. Если Nginx не может найти соответствующий ресурс, он вернет ошибку 404.</li>
<li><strong>location ~ .php</strong>: этот блок location обеспечивает фактическую обработку PHP, указывая Nginx на файл конфигурации <em>fastcgi-php.conf</em> и файл <em>php7.4-fpm.sock</em>, в котором объявляется, какой сокет связан с <em>php-fpm</em>.</li>
<li><strong>location ~ /.ht</strong>: последний блок location работает с файлами <em>.htaccess</em>, которые Nginx не обрабатывает. При добавлении директивы <em>deny all</em> любые файлы <em>.htaccess</em>, попавшие в корневой каталог проекта, не будут предоставляться посетителям.
Сохраните и закройте файл.
Активируйте свою конфигурацию, создав симлинк из каталога sites-enabled:</li>
</ul>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">ln</span> -s /etc/nginx/sites-available/your_domain /etc/nginx/sites-enabled/
</span></code></pre>
<p>Теперь Nginx сможет использовать конфигурацию при следующей перезагрузке. Сначала проверьте вашу конфигурацию на наличие ошибок:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> nginx -t
</span></code></pre>
<p>Если команда обнаружила какие-то ошибки, вернитесь и перепроверьте файл, прежде чем продолжить.
Исправив ошибки, перезагрузите Nginx, чтобы внести изменения в настройку:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> systemctl reload nginx
</span></code></pre>
<p>Ваш новый веб-сайт теперь включен, но корневой каталог /var/www/your_domain все еще пуст. Создайте в нем файл index.html, чтобы проверить, правильно ли работает ваш новый блок server:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$nano</span> /var/www/your_domain/index.html
</span></code></pre>
<p>Вставьте в файл такие строки:</p>
<pre class="language-html"><code class="language-html code-highlight"><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>html</span><span class="token punctuation">></span></span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>head</span><span class="token punctuation">></span></span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>title</span><span class="token punctuation">></span></span>your_domain website<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>title</span><span class="token punctuation">></span></span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>head</span><span class="token punctuation">></span></span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>body</span><span class="token punctuation">></span></span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>h1</span><span class="token punctuation">></span></span>Hello World!<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>h1</span><span class="token punctuation">></span></span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>p</span><span class="token punctuation">></span></span>This is the landing page of <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>strong</span><span class="token punctuation">></span></span>your_domain<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>strong</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>p</span><span class="token punctuation">></span></span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>body</span><span class="token punctuation">></span></span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>html</span><span class="token punctuation">></span></span>
</span></code></pre>
<p>Теперь откройте браузер и перейдите по своему домену или IP-адресу, который вы указали в server_name.</p>
<blockquote>
<p>http://server_domain_or_IP</p>
</blockquote>
<p>На экране вы увидите:</p>
<blockquote>
<p>Hello World!
This is the landing page of your_domain</p>
</blockquote>
<p>Если вы видите эту страницу, это означает, что ваш блок server работает должным образом.
Вы можете оставить этот файл как временную посадочную страницу своего приложения, пока не создадите файл <em>index.php</em> для его замены. Как только вы это сделаете, не забудьте удалить или переименовать файл index.html из корневого каталога, так как он будет иметь приоритет над файлом <em>index.php</em> по умолчанию.
Ваш стек LEMP теперь полностью настроен. Давайте далее создадим PHP-скрипт и убедимся, что Nginx действительно может обрабатывать файлы .php на вашем недавно настроенном веб-сайте.</p>
<h2 id="5тестирование-установки" class="heading">5.Тестирование установки</h2>
<p>Теперь установка стека LEMP полностью завершена. Пора убедиться, что веб-сервер успешно обслуживает файлы PHP.
Для этого нужно создать тестовый файл <em>info.php</em>_ в каталоге <em>document root</em>.</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$nano</span> /var/www/your_domain/info.php
</span></code></pre>
<p>Вставьте в этот файл такие строки:</p>
<pre class="language-php"><code class="language-php code-highlight"><span class="code-line"><span class="token php language-php"><span class="token delimiter important">&#x3C;?php</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token delimiter important">?></span></span>
</span></code></pre>
<p>Сохраните и закройте файл.
Теперь попробуйте открыть его в браузере:</p>
<blockquote>
<p>http://server_domain_or_IP/info.php</p>
</blockquote>
<p>На экране появится страница, содержащая информацию о сервере. Если такая страница появилась, Nginx правильно обслуживает файлы PHP.
После проверки обязательно удалите этот файл, иначе любой пользователь сможет получить доступ к конфиденциальным данным о сервере.</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">rm</span> /var/www/your_domain/info.php
</span></code></pre>
<p>При необходимости вы сможете легко восстановить эту страницу.</p>
<h2 id="6-тестирование-соединения-базы-данных-с-php-опционально" class="heading">6. Тестирование соединения базы данных с PHP (опционально)</h2>
<p>Если вы хотите проверить, может ли PHP подключаться к MySQL и выполнять запросы к базе данных, вы можете создать тестовую таблицу с фиктивными данными и запросить ее содержимое из сценария PHP.
Сначала нам нужно создать тестовую базу данных и пользователя для доступа к ней.
На момент написания этого мануала mysqlnd (PHP-библиотека для MySQL) не поддерживает caching_sha2_authentication, стандартный метод аутентификации MySQL 8. Нам нужно создать нового пользователя с аутентификацией mysql_native_password, чтобы иметь возможность подключиться к БД MySQL из PHP.
Давайте создадим базу данных example_database и пользователя example_user (вы можете заменить эти имена другими значениями).
Чтобы создать новую базу данных, войдите в СУБД как root:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> mysql
</span></code></pre>
<p>И выполните следующую команду из консоли MySQL:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> example_database<span class="token punctuation">;</span>
</span></code></pre>
<p>Теперь можно создать нового пользователя и предоставить ему полные права на новую базу данных.</p>
<p>Следующая команда создаст пользователя example_user, который поддерживает аутентификацию по методу mysql_native_password. Также команда определяет условный пароль этого пользователя (password), который вы должны заменить безопасным паролем.</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'example_user'</span><span class="token variable">@'%'</span> IDENTIFIED <span class="token keyword">WITH</span> mysql_native_password <span class="token keyword">BY</span> <span class="token string">'password'</span><span class="token punctuation">;</span>
</span></code></pre>
<p>Эта команда предоставит пользователю example_user полные права доступа к БД example_database:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">ON</span> example_database<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'example_user'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span>
</span></code></pre>
<p>В то же время она запретит ему создавать или изменять другие базы данных на вашем сервере.</p>
<p>После этого выйдите из оболочки MySQL:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token operator">></span><span class="token keyword">exit</span>
</span></code></pre>
<p>Вы можете убедиться, что у нового пользователя есть соответствующие права доступа. Снова войдите в консоль MySQL, на этот раз с помощью новых учетных данных:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$mysql</span> -u example_user -p
</span></code></pre>
<p>Обратите внимание на флаг -p в этой команде, он запрашивает пароль, который вы указали при создании пользователя example_user. После входа в консоль MySQL убедитесь, что у вас есть доступ к базе данных example_database:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token operator">></span><span class="token keyword">show</span> <span class="token keyword">databases</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token operator">+</span><span class="token comment">--------------------+</span>
</span><span class="code-line"><span class="token operator">|</span> <span class="token keyword">Database</span>           <span class="token operator">|</span>
</span><span class="code-line"><span class="token operator">+</span><span class="token comment">--------------------+</span>
</span><span class="code-line"><span class="token operator">|</span> example_database   <span class="token operator">|</span>
</span><span class="code-line"><span class="token operator">|</span> information_schema <span class="token operator">|</span>
</span><span class="code-line"><span class="token operator">+</span><span class="token comment">--------------------+</span>
</span><span class="code-line"><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.000</span> sec<span class="token punctuation">)</span>
</span></code></pre>
<p>Теперь создайте таблицу по имени todo_list. Для этого в консоли MySQL выполните следующую команду:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token operator">></span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> example_database<span class="token punctuation">.</span>todo_list <span class="token punctuation">(</span>
</span><span class="code-line">item_id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
</span><span class="code-line">content <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>item_id<span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>Вставьте в тестовую таблицу несколько строк данных. Для этого вы можете повторить следующую команду несколько раз, используя в ней разные значения:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token operator">></span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> example_database<span class="token punctuation">.</span>todo_list <span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">"My first important item"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>Чтобы убедиться, что данные были успешно сохранены в вашей таблице, запустите:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token operator">></span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> example_database<span class="token punctuation">.</span>todo_list<span class="token punctuation">;</span>
</span></code></pre>
<p>Вы увидите следующий вывод:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token operator">+</span><span class="token comment">---------+--------------------------+</span>
</span><span class="code-line"><span class="token operator">|</span> item_id <span class="token operator">|</span> content                  <span class="token operator">|</span>
</span><span class="code-line"><span class="token operator">+</span><span class="token comment">---------+--------------------------+</span>
</span><span class="code-line"><span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> My <span class="token keyword">first</span> important item  <span class="token operator">|</span>
</span><span class="code-line"><span class="token operator">|</span>       <span class="token number">2</span> <span class="token operator">|</span> My <span class="token keyword">second</span> important item <span class="token operator">|</span>
</span><span class="code-line"><span class="token operator">|</span>       <span class="token number">3</span> <span class="token operator">|</span> My third important item  <span class="token operator">|</span>
</span><span class="code-line"><span class="token operator">|</span>       <span class="token number">4</span> <span class="token operator">|</span> <span class="token operator">and</span> this one more thing  <span class="token operator">|</span>
</span><span class="code-line"><span class="token operator">+</span><span class="token comment">---------+--------------------------+</span>
</span><span class="code-line"><span class="token number">4</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.000</span> sec<span class="token punctuation">)</span>
</span></code></pre>
<p>Убедившись, что в тестовой таблице есть данные, вы можете выйти из консоли MySQL:</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token keyword">exit</span>
</span></code></pre>
<p>Теперь можно создать PHP-скрипт, который будет подключаться к MySQL и запрашивать контент. Создайте новый PHP-файл в корневом каталоге приложения.</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$nano</span> /var/www/your_domain/todo_list.php
</span></code></pre>
<p>Добавьте в PHP-скрипт следующие строки. Такой скрипт PHP подключается к базе данных MySQL и запрашивает содержимое таблицы todo_list, отображая результаты на экране в виде списка. Если у вас есть проблема с подключением к базе данных, он выдаст исключение.</p>
<pre class="language-php"><code class="language-php code-highlight"><span class="code-line"><span class="token php language-php"><span class="token delimiter important">&#x3C;?php</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token variable">$user</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"example_user"</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"password"</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token variable">$database</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"example_database"</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token variable">$table</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"todo_list"</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token keyword">try</span> <span class="token punctuation">{</span>
</span></span><span class="code-line"><span class="token php language-php">  <span class="token variable">$db</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PDO</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"mysql:host=localhost;dbname=<span class="token interpolation"><span class="token variable">$database</span></span>"</span><span class="token punctuation">,</span> <span class="token variable">$user</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php">  <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&#x3C;h2>TODO&#x3C;/h2>&#x3C;ol>"</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php">  <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$db</span><span class="token operator">-></span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"SELECT content FROM <span class="token interpolation"><span class="token variable">$table</span></span>"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$row</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span></span><span class="code-line"><span class="token php language-php">    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&#x3C;li>"</span> <span class="token operator">.</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'content'</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token string double-quoted-string">"&#x3C;/li>"</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php">  <span class="token punctuation">}</span>
</span></span><span class="code-line"><span class="token php language-php">  <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&#x3C;/ol>"</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PDOException</span> <span class="token variable">$e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token keyword">print</span> <span class="token string double-quoted-string">"Error!: "</span> <span class="token operator">.</span> <span class="token variable">$e</span><span class="token operator">-></span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token string double-quoted-string">"&#x3C;br/>"</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token punctuation">}</span>
</span></span><span class="code-line"><span class="token php language-php"><span class="token delimiter important">?></span></span>
</span></code></pre>
<p>Сохраните и закройте файл, когда закончите редактирование.
Теперь вы можете получить доступ к этой странице в своем веб-браузере, посетив домен, который вы указали в конфигурации веб-сервера. К нему нужно добавить секцию /todo_list.php:</p>
<blockquote>
<p>http://server_domain_or_IP/todo_list.php</p>
</blockquote>
<p>Вы должны увидеть свой контент, который вы добавили в тестовую таблицу.
Это означает, что среда PHP может подключаться и взаимодействовать с вашим сервером MySQL.</p>
<h2 id="заключение" class="heading">Заключение</h2>
<p>Теперь на вашем сервере установлен программный стек LEMP – надёжная и гибкая платформа для развёртывания сайта или приложения.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Установка Certbot на Nginx в Ubuntu 20.04]]></title>
    <link>https://it-integ.ru/certbot</link>
    <pubDate>2022-08-11</pubDate>
    <guid isPermaLink="false">https://it-integ.ru/certbot</guid>
    <description>
    <![CDATA[Как получить сертификат от Let’s Encrypt с помощью Certbot]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>Let’s Encrypt</strong> — это центр сертификации (ЦС), позволяющий легко получать и устанавливать бесплатные сертификаты TLS/SSL, что позволяет использовать на веб-серверах шифрованный трафик HTTPS. Это упрощает процесс посредством предоставления программного клиента Certbot, который пытается автоматизировать большинство необходимых шагов (или все шаги). В настоящее время весь процесс получения и установки сертификата полностью автоматизирован — как в Apache, так и Nginx.</p>
<p>В этом обучающем материале мы используем Certbot для получения бесплатного сертификата SSL для Nginx в Ubuntu 20.04 и настройки сертификата для автоматического продления. Вместо файла по умолчанию мы будем использовать отдельный файл конфигурации сервера Nginx. Мы рекомендуем создавать новые файлы серверных блоков Nginx для каждого домена, потому что это помогает избежать распространенных ошибок и сохранять файлы по умолчанию в качестве резервной конфигурации на случай отката.</p>
<h2 id="предварительные-требования" class="heading">Предварительные требования</h2>
<p>Для данного обучающего руководства вам потребуется следующее:</p>
<ul>
<li>Один сервер Ubuntu 20.04, настроенный в соответствии с обучающим модулем Начальная настройка сервера Ubuntu 20.04, включая пользователя без прав root с привилегиями sudo и брандмауэр.</li>
<li>Зарегистрированное доменное имя. В этом обучающем руководстве мы будем использовать example.com.</li>
<li>На вашем сервере должны быть настроены обе нижеследующие записи DNS:
<ul>
<li>Запись A, где example.com указывает на публичный IP-адрес вашего сервера.</li>
<li>Запись A, где <a href="http://www.example.com" target="_blank" rel="noopener noreferer">www.example.com</a> указывает на публичный IP-адрес вашего сервера.</li>
</ul>
</li>
<li>Nginx, установленный в соответствии с указаниями руководства Установка Nginx в Ubuntu 20.04. Убедитесь, что для вашего домена существует серверный блок. В качестве примера мы используем /etc/nginx/sites-available/example.com.</li>
</ul>
<h2 id="шаг-1--установка-certbot" class="heading">Шаг 1 — Установка Certbot</h2>
<p>Первый шаг для получения сертификата SSL от Let’s Encrypt — установить на сервере программное обеспечение Certbot. Установим Certbot и его плагин Nginx:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">apt</span> <span class="token function">install</span> certbot python3-certbot-nginx
</span></code></pre>
<p>Теперь Certbot готов к использованию, но для автоматической настройки конфигурации SSL для Nginx нам нужно частично проверить конфигурацию Nginx.</p>
<h2 id="шаг-2--настройка-конфигурации-nginx" class="heading">Шаг 2 — Настройка конфигурации Nginx</h2>
<p>Чтобы настраивать SSL автоматически, Certbot необходимо найти правильный серверный блок в вашей конфигурации Nginx. Для этого нужно найти директиву server_name, соответствующую домену, для которого вы запрашиваете сертификат. Для проверки откройте файл конфигурации вашего домена в nano или другом предпочитаемом текстовом редакторе:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> <span class="token function">nano</span> /etc/nginx/sites-available/example.com
</span></code></pre>
<p>Найдите строку:</p>
<blockquote>
<p>server_name example.com <a href="http://www.example.com" target="_blank" rel="noopener noreferer">www.example.com</a>;</p>
</blockquote>
<p>Если все нормально, закройте редактор и переходите к следующему шагу. Если нет, проведите обновление. Затем сохраните файл, закройте редактор и проверьте синтаксис внесенных правок конфигурации:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> nginx -t
</span></code></pre>
<p>Если вы получите сообщение об ошибке, откройте файл серверного блока заново и проверьте его на наличие опечаток или отсутствующих символов. Когда синтаксис файла конфигурации будет правильным, перезагрузите Nginx для загрузки новой конфигурации:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> systemctl reload nginx
</span></code></pre>
<p>Теперь Certbot сможет найти правильный серверный блок и автоматически обновлять его. Изменим настройки брандмауэра, чтобы он разрешал трафик HTTPS.</p>
<h2 id="шаг-3--доступ-к-https-через-брандмауэр" class="heading">Шаг 3 — Доступ к HTTPS через брандмауэр</h2>
<p>Если вы включили брандмауэр ufw в соответствии с предварительными требованиями, вам нужно будет настроить его так, чтобы разрешить трафик HTTPS. При установке Nginx регистрирует в ufw несколько профилей. Вы можете просмотреть текущие настройки с помощью следующей команды:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> ufw status
</span></code></pre>
<p>Возможно профиль будет выглядеть так, т. е. на веб-сервере будет разрешен только трафик HTTP:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"> Status: active
</span><span class="code-line"> <span class="token operator">|</span>       To      <span class="token operator">|</span>   Action    <span class="token operator">|</span>    From     <span class="token operator">|</span>
</span><span class="code-line"> <span class="token operator">|</span> :------------ <span class="token operator">|</span> :---------: <span class="token operator">|</span> ----------: <span class="token operator">|</span>
</span><span class="code-line"> <span class="token operator">|</span>    OpenSSH    <span class="token operator">|</span>    ALLOW    <span class="token operator">|</span>   Anywhere  <span class="token operator">|</span>
</span><span class="code-line"> <span class="token operator">|</span>    Nginx HTTP <span class="token operator">|</span>    ALLOW    <span class="token operator">|</span>   Anywhere  <span class="token operator">|</span>
</span></code></pre>
<p>Чтобы разрешить трафик HTTPS, активируйте профиль Nginx Full и удалите лишний профиль Nginx HTTP:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> ufw allow <span class="token string">'Nginx Full'</span>
</span><span class="code-line"><span class="token variable">$sudo</span> ufw delete allow <span class="token string">'Nginx HTTP'</span>
</span><span class="code-line"><span class="token variable">$sudo</span> ufw status
</span></code></pre>
<p>Теперь ваш статус должен выглядеть следующим образом:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"> Status: active
</span><span class="code-line"> <span class="token operator">|</span>       To      <span class="token operator">|</span>   Action    <span class="token operator">|</span>    From     <span class="token operator">|</span>
</span><span class="code-line"> <span class="token operator">|</span> :------------ <span class="token operator">|</span> :---------: <span class="token operator">|</span> ----------: <span class="token operator">|</span>
</span><span class="code-line"> <span class="token operator">|</span>    OpenSSH    <span class="token operator">|</span>    ALLOW    <span class="token operator">|</span>   Anywhere  <span class="token operator">|</span>
</span><span class="code-line"> <span class="token operator">|</span>    Nginx Full <span class="token operator">|</span>    ALLOW    <span class="token operator">|</span>   Anywhere  <span class="token operator">|</span>
</span></code></pre>
<p>Запустим Certbot и доставим наши сертификаты.</p>
<h2 id="шаг-4--получение-сертификата-ssl" class="heading">Шаг 4 — Получение сертификата SSL</h2>
<p>Certbot предоставляет широкий выбор способов получения сертификатов SSL с помощью плагинов: Плагин Nginx изменит конфигурацию Nginx и перезагрузит ее, когда это потребуется. Для использования этого плагина введите следующую команду:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> certbot --nginx -d example.com -d www.example.com
</span></code></pre>
<p>Эта команда запускает certbot с плагином <strong>--nginx</strong>, используя опцию <strong>-d</strong> для указания доменных имен, для которых мы хотим использовать сертификат. Если это первый запуск certbot , вам будет предложено указать адрес эл. почты и принять условия обслуживания. После этого certbot свяжется с сервером Let’s Encrypt и отправит запрос с целью подтвердить, что вы контролируете домен, для которого запрашиваете сертификат. Если это будет подтверждено, certbot запросит у вас предпочитаемый вариант настройки HTTPS:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"> Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.
</span><span class="code-line">
</span><span class="code-line"> ---
</span><span class="code-line">
</span><span class="code-line"> <span class="token number">1</span>: No redirect - Make no further changes to the webserver configuration.
</span><span class="code-line"> <span class="token number">2</span>: Redirect - Make all requests redirect to secure HTTPS access. Choose this <span class="token keyword">for</span>
</span><span class="code-line"> new sites, or <span class="token keyword">if</span> you<span class="token string">'re confident your site works on HTTPS. You can undo this
</span></span><span class="code-line"><span class="token string"> change by editing your web server'</span>s configuration.
</span><span class="code-line">
</span><span class="code-line"> ---
</span><span class="code-line">
</span><span class="code-line"> Select the appropriate number <span class="token punctuation">[</span><span class="token number">1</span>-2<span class="token punctuation">]</span> <span class="token keyword">then</span> <span class="token punctuation">[</span>enter<span class="token punctuation">]</span> <span class="token punctuation">(</span>press <span class="token string">'c'</span> to cancel<span class="token punctuation">)</span>:
</span><span class="code-line"> Выберите желаемый вариант, после чего нажмите ENTER. Конфигурация будет обновлена, а Nginx перезагрузится для получения новых настроек. Затем certbot завершит работу и выведет сообщение, подтверждающее завершение процесса и указывающее место хранения ваших сертификатов:
</span><span class="code-line">
</span><span class="code-line"> IMPORTANT NOTES:
</span><span class="code-line">
</span><span class="code-line"> - Congratulations<span class="token operator">!</span> Your certificate and chain have been saved at:
</span><span class="code-line">   /etc/letsencrypt/live/example.com/fullchain.pem
</span><span class="code-line">   Your key <span class="token function">file</span> has been saved at:
</span><span class="code-line">   /etc/letsencrypt/live/example.com/privkey.pem
</span><span class="code-line">   Your cert will expire on <span class="token number">2020</span>-08-18. To obtain a new or tweaked
</span><span class="code-line">   version of this certificate <span class="token keyword">in</span> the future, simply run certbot again
</span><span class="code-line">   with the <span class="token string">"certonly"</span> option. To non-interactively renew _all_ of
</span><span class="code-line">   your certificates, run <span class="token string">"certbot renew"</span>
</span><span class="code-line"> - If you like Certbot, please consider supporting our work by:
</span><span class="code-line">
</span><span class="code-line">   Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate
</span><span class="code-line">   Donating to EFF: https://eff.org/donate-le
</span></code></pre>
<p>Ваши сертификаты загружены, установлены и активированы. Попробуйте перезагрузить веб-сайт с помощью <strong>https://</strong> и посмотрите на индикатор безопасности в браузере. Теперь в браузере должен отображаться символ замка, означающий, что сайт защищен надлежащим образом. Если вы протестируете свой сервер с помощью теста SSL Labs Server Test, он получит оценку A. В заключение протестируем процесс обновления.</p>
<h2 id="шаг-5--проверка-автоматического-обновления-certbot" class="heading">Шаг 5 — Проверка автоматического обновления Certbot</h2>
<p>Сертификаты Let’s Encrypt действительны только в течение 90 дней. Это сделано для стимулирования пользователей к автоматизации процесса обновления сертификатов. Установленный нами пакет certbot выполняет это автоматически, добавляя таймер systemd, который будет запускаться два раза в день и автоматически продлевать все сертификаты, истекающие менее, чем через 30 дней. Вы можете запросить статус таймера с помощью команды systemctl:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> systemctl status certbot.timer
</span><span class="code-line">
</span><span class="code-line"> ● certbot.timer - Run certbot twice daily
</span><span class="code-line">
</span><span class="code-line"> Loaded: loaded <span class="token punctuation">(</span>/lib/systemd/system/certbot.timer<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>
</span><span class="code-line"> Active: active <span class="token punctuation">(</span>waiting<span class="token punctuation">)</span> since Mon <span class="token number">2020</span>-05-04 <span class="token number">20</span>:04:36 UTC<span class="token punctuation">;</span> <span class="token number">2</span> weeks <span class="token number">1</span> days ago
</span><span class="code-line"> Trigger: Thu <span class="token number">2020</span>-05-21 05:22:32 UTC<span class="token punctuation">;</span> 9h left
</span><span class="code-line"> Triggers: ● certbot.service
</span></code></pre>
<p>Чтобы протестировать процесс обновления, можно сделать запуск «вхолостую» с помощью certbot:</p>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line"><span class="token variable">$sudo</span> certbot renew --dry-run
</span></code></pre>
<p>Если ошибок нет, все нормально. Certbot будет продлевать ваши сертификаты, когда это потребуется, и перезагружать Nginx для активации изменений. Если процесс автоматического обновления когда-нибудь не выполнится, то Let’s Encrypt отправит сообщение на указанный вами адрес электронной почты с предупреждением о том, что срок действия сертификата подходит к концу.</p>]]>
    </content:encoded>
  </item>
    </channel>
  </rss>